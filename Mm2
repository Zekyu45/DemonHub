-- Script de t√©l√©portation automatique sur les pi√®ces
-- Services n√©cessaires
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

-- Variables globales
local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
local humanoid = character:WaitForChild("Humanoid")

-- Configuration
local TELEPORT_DELAY = 1 -- D√©lai en secondes entre chaque t√©l√©portation
local COIN_DETECTION_NAMES = {"Coin", "MainCoin", "CoinContainer", "Piece"} -- Noms possibles des pi√®ces
local SEARCH_DISTANCE = 1000 -- Distance maximale de recherche
local COLLECTION_CHECK_DELAY = 0.2 -- D√©lai pour v√©rifier si une pi√®ce a √©t√© collect√©e

-- Variables de contr√¥le
local isRunning = false
local coinsList = {}
local currentCoinIndex = 1
local collectedCoins = {} -- Table pour suivre les pi√®ces d√©j√† collect√©es

-- Fonction pour v√©rifier si une pi√®ce est encore disponible/collectible
local function isCoinAvailable(coinObject)
    if not coinObject or not coinObject.Parent then
        return false
    end
    
    -- V√©rifier si cette pi√®ce a d√©j√† √©t√© marqu√©e comme collect√©e
    if collectedCoins[coinObject] then
        return false
    end
    
    -- V√©rifier si l'objet est visible et actif
    if coinObject:IsA("BasePart") then
        -- Une pi√®ce est disponible si elle est visible (transparency < 1) et peut √™tre touch√©e
        local isVisible = coinObject.Transparency < 1
        local hasValidPosition = coinObject.Position and coinObject.Position.Magnitude > 0
        return isVisible and hasValidPosition
    elseif coinObject:IsA("Model") then
        -- Pour un mod√®le, v√©rifier s'il a des parts visibles
        local hasVisibleParts = false
        for _, part in pairs(coinObject:GetChildren()) do
            if part:IsA("BasePart") and part.Transparency < 1 then
                hasVisibleParts = true
                break
            end
        end
        return hasVisibleParts
    end
    
    return false
end

-- Fonction pour marquer une pi√®ce comme collect√©e
local function markCoinAsCollected(coinObject)
    if coinObject then
        collectedCoins[coinObject] = true
    end
end

-- Fonction pour nettoyer les pi√®ces collect√©es de la m√©moire
local function cleanupCollectedCoins()
    local cleanedCoins = {}
    for coin, _ in pairs(collectedCoins) do
        -- Garder seulement les pi√®ces qui existent encore (pour √©viter les fuites m√©moire)
        if coin and coin.Parent then
            cleanedCoins[coin] = true
        end
    end
    collectedCoins = cleanedCoins
end

-- Fonction pour d√©tecter toutes les pi√®ces disponibles dans le workspace
local function detectCoins()
    local foundCoins = {}
    
    -- Fonction r√©cursive pour chercher dans tous les descendants
    local function searchInDescendants(parent)
        for _, child in pairs(parent:GetDescendants()) do
            -- V√©rifier si l'objet correspond √† un nom de pi√®ce
            for _, coinName in pairs(COIN_DETECTION_NAMES) do
                if string.find(child.Name:lower(), coinName:lower()) then
                    -- V√©rifier si la pi√®ce est disponible avant de l'ajouter
                    if isCoinAvailable(child) then
                        -- V√©rifier si l'objet a une position (Part, MeshPart, etc.)
                        if child:IsA("BasePart") and child.Position then
                            table.insert(foundCoins, {
                                object = child,
                                position = child.Position,
                                name = child.Name
                            })
                        -- Si c'est un Model, prendre sa position primaire ou le premier part
                        elseif child:IsA("Model") then
                            local primaryPart = child.PrimaryPart
                            if primaryPart then
                                table.insert(foundCoins, {
                                    object = child,
                                    position = primaryPart.Position,
                                    name = child.Name
                                })
                            else
                                -- Chercher le premier Part dans le mod√®le
                                for _, part in pairs(child:GetChildren()) do
                                    if part:IsA("BasePart") then
                                        table.insert(foundCoins, {
                                            object = child,
                                            position = part.Position,
                                            name = child.Name
                                        })
                                        break
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
    end
    
    -- Chercher dans tout le workspace
    searchInDescendants(Workspace)
    
    return foundCoins
end

-- Fonction pour t√©l√©porter le joueur √† une position
local function teleportToPosition(position)
    if humanoidRootPart and position then
        -- Ajouter un petit offset en hauteur pour √©viter de se coincer dans le sol
        local teleportPosition = Vector3.new(position.X, position.Y + 5, position.Z)
        humanoidRootPart.CFrame = CFrame.new(teleportPosition)
        
        print("T√©l√©port√© √† la position:", teleportPosition)
    end
end

-- Fonction pour trier les pi√®ces par distance
local function sortCoinsByDistance(coins)
    if not humanoidRootPart then return coins end
    
    table.sort(coins, function(a, b)
        local distanceA = (a.position - humanoidRootPart.Position).Magnitude
        local distanceB = (b.position - humanoidRootPart.Position).Magnitude
        return distanceA < distanceB
    end)
    
    return coins
end

-- Fonction principale de t√©l√©portation automatique
local function startAutoTeleport()
    isRunning = true
    print("D√©marrage de la t√©l√©portation automatique sur les pi√®ces...")
    
    spawn(function()
        while isRunning do
            -- D√©tecter toutes les pi√®ces disponibles
            coinsList = detectCoins()
            
            if #coinsList > 0 then
                -- Trier par distance pour optimiser le parcours
                coinsList = sortCoinsByDistance(coinsList)
                
                print("Pi√®ces disponibles d√©tect√©es:", #coinsList)
                
                -- T√©l√©porter sur chaque pi√®ce disponible
                for i, coinData in pairs(coinsList) do
                    if not isRunning then break end
                    
                    -- Triple v√©rification : la pi√®ce existe, est disponible et n'a pas √©t√© collect√©e
                    if coinData.object and coinData.object.Parent and isCoinAvailable(coinData.object) then
                        teleportToPosition(coinData.position)
                        print("T√©l√©port√© sur pi√®ce disponible:", coinData.name)
                        
                        -- Petite attente pour laisser le temps √† la collection de se faire
                        task.wait(COLLECTION_CHECK_DELAY)
                        
                        -- V√©rifier si la pi√®ce a √©t√© collect√©e apr√®s t√©l√©portation
                        if not isCoinAvailable(coinData.object) then
                            markCoinAsCollected(coinData.object)
                            print("‚úì Pi√®ce collect√©e:", coinData.name)
                        else
                            print("‚ö† Pi√®ce non collect√©e:", coinData.name)
                        end
                        
                        -- Attendre le d√©lai sp√©cifi√©
                        task.wait(TELEPORT_DELAY - COLLECTION_CHECK_DELAY)
                        
                    else
                        print("‚ùå Pi√®ce non disponible ignor√©e:", coinData.name)
                    end
                    
                    -- Re-d√©tecter les pi√®ces toutes les 3 t√©l√©portations pour capturer les nouvelles
                    if i % 3 == 0 then
                        print("üîÑ Re-d√©tection des nouvelles pi√®ces...")
                        cleanupCollectedCoins() -- Nettoyer la m√©moire
                        task.wait(0.5) -- Petite pause pour laisser le temps aux nouvelles pi√®ces d'appara√Ætre
                        break -- Sortir de la boucle pour re-d√©tecter
                    end
                end
            else
                print("Aucune pi√®ce disponible d√©tect√©e, nouvelle recherche dans 2 secondes...")
                task.wait(2)
            end
            
            -- Petite pause avant la prochaine d√©tection compl√®te
            task.wait(0.5)
        end
    end)
end

-- Fonction pour arr√™ter la t√©l√©portation
local function stopAutoTeleport()
    isRunning = false
    collectedCoins = {} -- R√©initialiser la liste des pi√®ces collect√©es
    print("T√©l√©portation automatique arr√™t√©e.")
end

-- Gestion de la reconnexion du personnage
player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    humanoid = character:WaitForChild("Humanoid")
    print("Nouveau personnage d√©tect√©, red√©marrage du script...")
end)

-- Interface simple pour contr√¥ler le script
local function createControlGUI()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "CoinTeleportControl"
    screenGui.Parent = player:WaitForChild("PlayerGui")
    
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 200, 0, 100)
    frame.Position = UDim2.new(0, 10, 0, 10)
    frame.BackgroundColor3 = Color3.fromRGB(50, 50, 50)
    frame.BorderSizePixel = 2
    frame.Parent = screenGui
    
    local startButton = Instance.new("TextButton")
    startButton.Size = UDim2.new(0, 90, 0, 30)
    startButton.Position = UDim2.new(0, 5, 0, 5)
    startButton.BackgroundColor3 = Color3.fromRGB(0, 255, 0)
    startButton.Text = "START"
    startButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    startButton.Parent = frame
    
    local stopButton = Instance.new("TextButton")
    stopButton.Size = UDim2.new(0, 90, 0, 30)
    stopButton.Position = UDim2.new(0, 105, 0, 5)
    stopButton.BackgroundColor3 = Color3.fromRGB(255, 0, 0)
    stopButton.Text = "STOP"
    stopButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    stopButton.Parent = frame
    
    local statusLabel = Instance.new("TextLabel")
    statusLabel.Size = UDim2.new(1, 0, 0, 30)
    statusLabel.Position = UDim2.new(0, 0, 0, 40)
    statusLabel.BackgroundTransparency = 1
    statusLabel.Text = "Status: Arr√™t√©"
    statusLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    statusLabel.Parent = frame
    
    local coinsLabel = Instance.new("TextLabel")
    coinsLabel.Size = UDim2.new(1, 0, 0, 25)
    coinsLabel.Position = UDim2.new(0, 0, 0, 70)
    coinsLabel.BackgroundTransparency = 1
    coinsLabel.Text = "Pi√®ces: 0"
    coinsLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
    coinsLabel.TextScaled = true
    coinsLabel.Parent = frame
    
    -- √âv√©nements des boutons
    startButton.MouseButton1Click:Connect(function()
        if not isRunning then
            startAutoTeleport()
            statusLabel.Text = "Status: En cours"
        end
    end)
    
    stopButton.MouseButton1Click:Connect(function()
        if isRunning then
            stopAutoTeleport()
            statusLabel.Text = "Status: Arr√™t√©"
        end
    end)
    
    -- Mise √† jour du compteur de pi√®ces
    spawn(function()
        while true do
            coinsLabel.Text = "Pi√®ces: " .. #coinsList
            task.wait(1)
        end
    end)
end

-- Initialisation
print("Script de t√©l√©portation sur les pi√®ces charg√©!")
print("Commandes disponibles:")
print("- startAutoTeleport() : D√©marrer la t√©l√©portation automatique")
print("- stopAutoTeleport() : Arr√™ter la t√©l√©portation automatique")

-- Cr√©er l'interface de contr√¥le
createControlGUI()

-- D√©marrage automatique (optionnel - d√©commentez la ligne suivante)
-- startAutoTeleport()
